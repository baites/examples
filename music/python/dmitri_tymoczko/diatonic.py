import itertools
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from music21 import *

"""

TODO:
	REWRITE so that duplicate PCs are always spelled with a unique lettername?  Deal with spelling better in any case.  (Perhaps allow the user to decide their own spelling?)

Transform chord- and voice-leading progressions from one scale to another, and from one size chord to another, in a theoretically sensible way.

	requires music21 and matplotlib (consider the Fonnesbeck ScipySuperpack for the latter)

For background:

	1. "Geometry and the Quest for Theoretical Generality"	-- especially the material about the "generalized circle of fifths"
	2. "A Geometry of Music" -- chapter 3, discusses building analogous voice leading lattices in different spaces, when the size of the chord is relatively prime to the size of the scale

This program puts these two ideas together, building a "generalized circle of fifths" from *any* chord [1] and using that to generate analogues to the melodic minor, harmonic minor,
etc. [2].  This combination of ideas has not, unfortunately, been described in print anywhere yet; it should've been in [1]

The fundamental idea is that voice leadings can be associated by the total effect they have on the sum of a chord's pitch classes.  Moving along a chord's "generalized circle of fifths"
changes the PC sum by 1 (+/- depending on direction).  When the chord is maximally even this manifests itself as single step voice leading in a single voice; for less even chords, the
voice leading is more complicated and leap-y.

Subsidiary sets are generated by scrambling the voice leadings on this "circle of fifths" [2, chapter 3].  Again, voice leadings can be categorized by the change of the sum of a chord's
PCs.

So, in two different realms "the voice leading that moves the central chord to the central chord changing the sum by +3" can be associated.
Similarly, "the voice leading that moves the central chord to the first subsidiary  chord changing the sum by -2" can be associated, at least in principle.  So we have a mapping,
based the the "circle of fifths" and the scrambling of its voice leadings, that associates chords in different circumstances.  What this means aurally is TBD!

How to use:

	- theScale gives the ambient scale in which we are operating, expressed in terms of familiar PC numbers.

		It is mostly used in I/O, so it can be anything; the primary functionally relevant feature is the length

		[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]			for standard 12tet
		[0, 2, 4, 5, 7, 9, 11] 							for the standard diatonic
		[1, 3, 6, 8, 10]								for black-note pentatonic
		[0, 1, 2, 3, 4] 								for 5tet

	- baseSet is the chord whose generalized "circle of fifths" is going to construct the central voice-leading lattice
		if this is unspecified, we default to the maximally even chord of size dimension

	- dimension is the dimension of the voice leading lattice
		if this is unspecified, the program defaults to the length of baseSet
		you might use this parameter if you only want a 3D lattice involving a 7-note chord inside a 12-note chromatic scale, for example;
		calculating the 7D graph takes a noticeable amount of time

	- ADVANCED: the baseVL parameter allows you to specify a different "circle of fifths voice leading."  For instance

		y = diatonic.ChordGraph([0, 1, 4], 2, [0, 2, 4, 5, 7, 9, 11],  baseVL = [0, 2, 0])

				creates a base voice leading (C, D, G) -> (C, F, G) which is in some contexts more useful than the standard circle of thirds VL (C, D, G) -> (B, E, A)

		similarly, x = diatonic.ChordGraph([0, 2, 4, 6, 7, 9, 10], 2, 12, baseVL = [0, 0, 0, 0, 1, 0, 1])

				creates a base voice leading (C, D, E, F#, G, A, Bb) -> (C, D, E, F#, G#, A, B) which again may be a more useful generator than the standard signature transform

Initialize as follows:

	x = diatonic.ChordGraph(baseSet, [dimension], theScale)

You can use keyword arguments or regular arguments; baseSet and theScale can be expressed as explicit lists or as numbers.  For theScale, a number implies
a list of the form [0, 1, 2, ...], for baseSet, it implies the maximally even chord of that length.  theScale defaults to the diatonic if unspecified.

Then construct voice leadings like so:

	x.move_chord(cSet, distance, destSetNumber)

		cSet is a  pitch set in standard midi numbers; the output is again a pitch set in standard midi numbers.
		distance is the distance to move along the lattice (positive or negative), expressed as the difference between the sum of the startpitches and that of the endpitches
		destSetNumber identifies the destination set class in the order given by self.possibleSets

	it will return a tuple ([outputPitches], sumDifference).  The second parameter is just for debugging purposes; I will eliminate it when I am convinced this works.

	x.chord_sequence(startPitches, intervalSequence, multiplier).  Uses music21 to show in notation a large sequence of chord motions.

		pass it:
			- a list of start pitches
			- an interval sequence [x_1, x_2, ..., x_n], where the x_i are either
					- integers indicating the change in chords' sums, equivalent to the distance parameter in move_chord (sends the chord back to the main spine); or
					- lists [i, j] where i gives the change of the chord's sum and j gives the destination chord on the lattice
			- multiplier multiplies all intervals by a fixed amount (larger chords may need more motion)

		the resulting voice leadings are shown in your notation program

	x.arpeggiate produces an arpeggiated version of the chord_sequence previously generated

	x.graph() will depict the voice leading possibilities ******* THIS IS VERY VERY VERY USEFUL *******

	x.apply(secondChordGraphObject): allows you to embed one chord_sequence inside another.
		The idea is that secondChordGraphObject acts like a kind of scale within which x moves around.  This can be iterated to produce multilevel, pseudofractal embodiments
		of the same basic voice-leadings tructure.

If you initialize two ChordGraph classes, move_chord(X, distance, destSetNumber), or chord_sequence(X, theSeq) can create analogous patterns in the two musical worlds.

Important Information:

	x.possibleSets: Once you initialize x = diatonic.ChordGraph(baseSet, [dimension], theScale), you can use x.possibleSets to get the possible chord types on the lattice.  T
		These are ordered, with the first set being set-type 0 (the baseSet, or central chord of the lattice), the second set-type 1, the third set-type 2, etc.
		These numbers are used in the move_chord method.

	x.theCircle: gives the basic "circle of fifths" voice leading that generates the chord lattice.
		Scrambling these voice leadings gives the rest of the lattice and takes you away from the base set.

One interesting thought is that the circle of semitones is the degenerate one-dimensional analogue of the "generalized circle of fifths"; so you can map a single melody into a
sequence of chords.

"""

def VL_paths(source, target):
	return  [(target[i] - source[i]) for i in range(len(source))]

def divides(i, j):
	return j == i * (j//i)

def normal_form(inList, invert = False, modulus = 12):			# takes a list of midi numbers; copied from DT.py
	listOfPCs = sorted([k % modulus for k in inList])
	currentBest = [k - listOfPCs[0] for k in listOfPCs]
	newChallenger = currentBest[:]
	normal_form.transposition = -listOfPCs[0] % 12
	normal_form.inversion = False
	for i in range(1, len(listOfPCs)):
		newChallenger = newChallenger[1:] + [newChallenger[0] + modulus]
		newChallenger = [k - newChallenger[0] for k in newChallenger]
		transp = -listOfPCs[i] % 12
		for j in reversed(range(0, len(listOfPCs))):
			if newChallenger[j] < currentBest[j]:
				currentBest = newChallenger
				normal_form.transposition = transp
			else:
				if newChallenger[j] > currentBest[j]:
					break
	if invert:
		listOfPCs = sorted([(modulus - k) % modulus for k in inList])
		for i in range(len(listOfPCs)):
			newChallenger = listOfPCs[-i:] + listOfPCs[:-i]
			newChallenger = sorted([(k - newChallenger[0]) % modulus for k in newChallenger])
			for j in reversed(range(0, len(listOfPCs))):
				if newChallenger[j] < currentBest[j]:
					currentBest = newChallenger
				else:
					if newChallenger[j] > currentBest[j]:
						break
	return currentBest

def vl_normal_form(inList):										# list of [PC, path] pairs ... merge this with normal_form?
	myList = sorted([[k[0] % 12] + k[1:] for k in inList])
	currentBest = [[(k[0] - myList[0][0]) % 12] + k[1:] for k in myList]
	vl_normal_form.transposition = myList[0][0] * -1
	for i in range(1, len(myList)):
		newChallenger = myList[-i:] + myList[:-i]
		transp = newChallenger[0][0] * -1
		newChallenger = sorted([[(k[0] - newChallenger[0][0]) % 12] + k[1:] for k in newChallenger])
		for j in reversed(range(len(myList))):
			if newChallenger[j][0] < currentBest[j][0]:
				currentBest = newChallenger
				vl_normal_form.transposition = transp
			else:
				if newChallenger[j][0] > currentBest[j][0]:
					break
	return currentBest

def make_square(startVertex, v1 = [1, 1], v2 = [1, -1]):
	seq = [v1, v2, negative(v1), negative(v2)]
	finalSeq = []
	finalSeq.append(startVertex)
	for v in seq:
		finalSeq.append(add_vectors(finalSeq[-1], v))
	return finalSeq

def make_cube(startVertex, endVertex):
	xVec = [endVertex[0] - startVertex[0], 0, 0]
	yVec = [0, endVertex[1] - startVertex[1], 0]
	zVec = [0, 0, endVertex[2] - startVertex[2]]
	seq = [xVec, yVec, negative(xVec), negative(yVec), zVec, xVec, negative(zVec), yVec, zVec, negative(xVec), negative(zVec), zVec, negative(yVec), xVec, yVec]
	finalSeq = []
	finalSeq.append(startVertex)
	for v in seq:
		finalSeq.append(add_vectors(finalSeq[-1], v))
	return finalSeq

def PCs_to_strings(myList):
	return ''.join([str(x).replace('10', 'T').replace('11', 'E') for x in myList])

circleOfFifths = {6: [0, 12], 1: [1, 13], 8: [2, 14], 3: [3, 15], 10: [4, 16], 5: [5, 17], 0: [6], 7: [7], 2: [8], 9: [9], 4: [10], 11:[11]}
outNames = ['Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#']

def spell(listOfPCs):

	fifths = []
	for i in range (18):
		fifths.append([])
	pcSet = set(listOfPCs)

	for p in pcSet:
		for s in circleOfFifths[p]:
			fifths[s].append(p)

	spellingStart = [0] * 18

	for i in range(len(spellingStart)):
		foundPCs = set([])
		spellingStart[i] = 999999
		for j in range(i, len(spellingStart)):
			if fifths[j]:
				foundPCs.add(fifths[j][0])
				if len(foundPCs) == len(pcSet):
					spellingStart[i] = j - i + 1
					break

	outDict = {}
	endPoint = min(spellingStart)
	spellStart = spellingStart.index(endPoint)

	for i in range(spellStart, spellStart + endPoint):
		if fifths[i]:
			outDict[fifths[i][0]] = outNames[i]

	output = []
	for i in listOfPCs:
		output.append(outDict[i])

	return output

def add_vectors(x, y):
	return [x[i] + y[i] for i in range(len(x))]

def negative(x):
	return [-i for i in x]

def separate_coordinates(thePoints):
	outList = []
	tempLen = len(thePoints[0])
	for i in range(tempLen):
		outList.append([])
	for p in thePoints:
		for i in range(tempLen):
			outList[i].append(p[i])
	return outList

class ChordGraph():

	WhiteNotes = {0: 'C', 2:'D', 4:'E', 5:'F', 7:'G', 9:'A', 11:'B'}
	FlatNames = {1: 'Db', 3:'Eb', 6:'Gb', 8:'Ab', 10:'Bb'}
	SharpNames = {1: 'C#', 3:'D#', 6:'F#', 8:'G#', 10:'A#'}

	def __init__(self, *args, **kwargs):
		theScale = []
		dimension = 0
		baseSet = []
		if 'theScale' in kwargs:
			theScale = kwargs['theScale']
		if 'dimension' in kwargs:
			dimension = kwargs['dimension']
		if 'dim' in kwargs:
			dimension = kwargs['dim']
		if 'baseSet' in kwargs:
			baseSet = kwargs['baseSet']
		if 'baseVL' in kwargs:
			self.baseVL = kwargs['baseVL']
		else:
			self.baseVL = []
		if len(args) == 1:							# one arg is chord size in 7
			theScale = [0, 2, 4, 5, 7, 9, 11]
			if type(args[0]) is int:
				dimension = args[0]
			elif type(args[0]) is list:
				baseSet = args[0]
		elif len(args) == 2:
			if type(args[-1]) is int:
				theScale = range(args[-1])
			elif type(args[-1]) is list:
				theScale = args[-1]
			if type(args[0]) is int:
				dimension = args[0]
			elif type(args[0]) is list:
				baseSet = args[0]
		elif len(args) == 3:
			if type(args[-1]) is int:
				theScale = range(args[-1])
			elif type(args[-1]) is list:
				theScale = args[-1]
			dimension = args[1]
			if type(args[0]) is int:
				baseSet = [int(x * (1.0 * len(theScale) / args[0])) for x in range(args[0])]
			elif type(args[0]) is list:
				baseSet = args[0]
		if not theScale:
			theScale = [0, 2, 4, 5, 7, 9, 11]
		if not dimension and not baseSet:
			dimension = 3
		self.set_scale(theScale)
		self.baseVLsum = 1
		if dimension and not baseSet:															# choose the most even chord by default
			baseSet = [int(x * (1.0 * self.modulus / dimension)) for x in range(dimension)]
		if baseSet:																		# make an n-dimensional graph by default
			if not dimension:
				dimension = len(baseSet)
			if dimension >= len(theScale):
				print ("Base set must be strictly smaller than the enclosing scale")
				return
			for i in range(2, dimension + 1):
				if divides(i, len(theScale)) and divides(i, len(baseSet)):
					print ("Length of the base set must be relatively prime to that of the enclosing scale")
					return
			self.baseSetLen = len(baseSet)
			self.dimension = dimension
			if self.baseVL:
				tempBaseVL = [[baseSet[i], self.baseVL[i]] for i in range(self.baseSetLen)]
				tempBaseVL = vl_normal_form(tempBaseVL)
				baseSet = [x[0] for x in tempBaseVL]
				self.baseVL = [x[1] for x in tempBaseVL]
				self.baseVLsum = sum(self.baseVL)
			else:
				baseSet = normal_form(baseSet, modulus = self.modulus)
			self.baseSet = baseSet
			self.possible_sets(baseSet, dimension)
			self.lastVLpaths = []

	def set_scale(self, newNotes):
		self.theScale = newNotes
		self.modulus = len(newNotes)
		self.theCircle = []
		self.possibleSets = []
		self.voiceLeadings = {}
		self.chordHistory = []
		self.pitchScale = {}
		self.inversePitchScale = {}
		self.lastInput = []
		self.lastOutput = []

		lastNote = min(self.theScale)
		j = 0
		i = self.theScale.index(lastNote)
		while lastNote < 127:
			i = (i + 1) % self.modulus
			j += 1
			newPC = self.theScale[i] + (lastNote / 12) * 12
			if newPC < lastNote:
				newPC += 12
			self.pitchScale[j] = newPC
			lastNote = newPC
		s = sorted(self.pitchScale.items(), key = lambda x: abs(60 - x[1]))
		offset = 60 - s[0][0]
		newDict = {}
		for item in self.pitchScale:
			newDict[item + offset] = self.pitchScale[item]
		self.pitchScale = newDict
		self.inversePitchScale = {v: k for k, v in self.pitchScale.items()}

	def whole_circle(self, dSet):
		self.theCircle = []
		tempSet = dSet[:]
		for dummy in range(len(dSet)):
			if not self.baseVL:
				theVL = self.circle_VL(tempSet)
				newSet = [(theVL[i] + tempSet[i]) % self.modulus for i in range(len(dSet))]
			else:
				newSet = self.apply_VL(tempSet, [self.baseSet, self.baseVL])
				newSet = [x % self.modulus for x in newSet]
				theVL = self.lastVLpaths
			if newSet != dSet:
				self.theCircle.append([tempSet, theVL])
			tempSet = newSet

	def possible_sets(self, dSet, myRange = 0, printCrossings = False):
		if not myRange:
			myRange = len(dSet)
		tempSets = []
		self.whole_circle(dSet)
		self.voiceLeadings = {}
		for vlSeq in itertools.permutations(range(myRange)):
			curSet = dSet[:]
			for i in vlSeq:
				curSet = [curSet[j] + self.theCircle[i][1][j] for j in range(self.baseSetLen)]
				testSet = [curSet[j] - curSet[0] for j in range(self.baseSetLen)]
				if printCrossings and ((not all(testSet[i] <= testSet[i+1] for i in xrange(self.baseSetLen - 1))) or testSet[-1] > self.modulus):
					newCurSet = dSet[:]
					print("CROSSING!", normal_form(testSet, modulus = self.modulus), end = '')
					for k in vlSeq:
						print(self.theCircle[k][1], end = '')
						newCurSet = [newCurSet[j] + self.theCircle[k][1][j] for j in range(self.baseSetLen)]
						print(newCurSet, end = '')
					print()
				elif printCrossings:
					print("  no crossing", normal_form(testSet, modulus = self.modulus))
				destChord = tuple(normal_form(curSet, invert = False, modulus = self.modulus))
				totalVL = [curSet[j] - dSet[j] for j in range(self.baseSetLen)]
				theSum = sum(totalVL)
				if destChord in self.voiceLeadings:
					if abs(theSum) < abs(sum(self.voiceLeadings[destChord])):
						self.voiceLeadings[destChord] = totalVL
				else:
					self.voiceLeadings[destChord] = totalVL
				tempSets.append(destChord)
		self.possibleSets = []
		for t in tempSets:
			if t not in self.possibleSets:
				self.possibleSets.append(t)
		self.possibleSets = [list(x) for x in self.possibleSets]

	def circle_VL(self, dSet):
		startSet = [(x - dSet[0]) % self.modulus for x in dSet]
		theSum = sum(startSet) % self.modulus
		foundIt = False
		newSet = startSet[:]
		for i in range(self.modulus):
			newSet = [(x + 1) for x in newSet]
			newSum = (sum(newSet) - theSum) % self.modulus
			if newSum == 1:
				foundIt = True
				break
		if not foundIt:
			print("ERROR! can't find target chord")
			return False
		for i in range(self.baseSetLen):
			theVL = VL_paths(startSet, newSet)
			while sum(theVL) > 1:
				theVL = [x - self.modulus for x in theVL]
			if sum(theVL) == 1:
				return theVL
			newSet = newSet[1:] + [newSet[0] + self.modulus]
		return False


	def move_chord(self, cSet, distance = 0, destSetNumber = 0):

		"""The core method: takes an input chromatic set of pitches (cSet) and outputs
			- a set of pitches that changes the sum by distance while changing the quality of the chord to destSetNumber
			- also outputs other information [the VL in diatonic steps and the total change of diatonic sum] for debugging purposes"""

		distance = distance * self.baseVLsum

		dSet = [self.inversePitchScale[x] for x in cSet]

		spineTarget = self.move_perpendicular_to_spine(dSet, 0)
		tempVL = self.lastVLpaths[:]												# keep track of total VL path for debugging
		tempTarget = self.move_perpendicular_to_spine(spineTarget, destSetNumber)

		distanceOffset = (sum(tempTarget) - sum(dSet))

		tempTarget = self.move_along_spine(spineTarget, (distance - distanceOffset) / self.baseVLsum)

		tempVL = [tempVL[i] + self.lastVLpaths[i] for i in range(self.baseSetLen)]

		totalOutput = self.move_perpendicular_to_spine(tempTarget, destSetNumber)
		tempVL = [tempVL[i] + self.lastVLpaths[i] for i in range(self.baseSetLen)]

		return [self.pitchScale[x] for x in totalOutput], tempVL, sum(totalOutput) - sum(dSet)

	def move_along_spine(self, dSet, distance):

		"""moves along the central circle-of-fifths by DISTANCE steps"""

		NFchord = normal_form(dSet, invert = False, modulus = self.modulus)

		if NFchord != self.possibleSets[0]:
			print("NOT THE MAIN SPINE CHORD", NFchord)
			return
		totalVL = [0] * self.baseSetLen
		if distance > 0:
			for i in range(distance):
				totalVL = [totalVL[j] + self.theCircle[i % len(self.theCircle)][1][j] for j in range(self.baseSetLen)]
		elif distance < 0:
			for i in range(1, (-1 * distance) + 1):
				totalVL = [totalVL[j] - self.theCircle[-i % len(self.theCircle)][1][j] for j in range(self.baseSetLen)]
		return self.apply_VL(dSet, [self.theCircle[0][0], totalVL])

	def move_perpendicular_to_spine(self, dSet, destSetNumber):

		"""moves between different kinds of chords, 'perpendicular' to the circle of fifths
				actually, the motion is not really perpendicular; instead it has the same basic quality (ascending/descending) as the basic VL generating the
				main circle; we correct this in the move_chord routine, with distanceOffset making the motion genuinely perpendicular"""

		NFchord = normal_form(dSet, invert = False, modulus = self.modulus)
		totalVL = [0] * self.baseSetLen

		if NFchord != self.possibleSets[0]:
			if NFchord not in self.possibleSets:
				print("CAN'T FIND CHORD", NFchord)
				return
			else:
				totalVL = [-self.voiceLeadings[tuple(NFchord)][x] for x in range(self.baseSetLen)]
				NFchord = [self.baseSet[x] + self.voiceLeadings[tuple(NFchord)][x] for x in range(self.baseSetLen)]
				tempChord  = self.apply_VL(dSet, [NFchord, totalVL])

		destSet = tuple(self.possibleSets[destSetNumber])
		totalVL = [totalVL[x] + self.voiceLeadings[destSet][x] for x in range(self.baseSetLen)]
		return self.apply_VL(dSet, [NFchord, totalVL])

	def apply_VL(self, dSet, theVL):

		"""Given a voiceleading theVL = [[startPCs], [paths]] and a diatonic pitch set dSet, return the appropriate pitches"""
		baseSet, totalVL = theVL

		failure = True
		dSetPCs = set([x % self.modulus for x in dSet])

		for i in range(self.modulus):							# transpose pitches until they match dSet
			if set(baseSet) == dSetPCs:
				failure = False
				break
			baseSet = [(x + 1) % self.modulus for x in baseSet]

		if failure:
			print("CAN'T APPLY VOICE LEADING!!!!")

		outputNotes = []
		takenNotes = []
		for i in dSet:
			for j in range(len(baseSet)):
				if i % self.modulus == baseSet[j] and j not in takenNotes:
					outputNotes.append([totalVL[j], i + totalVL[j]])		# saving both startPC and dest PC, can fix this
					takenNotes.append(j)
					break

		self.lastVLpaths = [x[0] for x in outputNotes]
		return [x[1] for x in outputNotes]


	"""Simple wrapper to explore the diatonic voice leading lattices

		pass it:
			- a list of start pitches
			- an interval sequence [x_1, x_2, ..., x_n], where the x_i are either
					- integers indicating the change in chords' sums (sends the chord back to the main spine); or
					- lists [i, j] where i gives the change of the chord's sum and j gives the destination chord on the lattice
			- multiplier multiplies all intervals by a fixed amount (larger chords may need more motion)

		the resulting voice leadings are shown in your notation program"""

	def chord_sequence(self, startNotes, intervalSequence, multiplier = 1, show = True):
		self.output = stream.Score()
		for i in range(len(startNotes)):
			self.output.insert(0, stream.Part())
		totalNotes = []
		curNotes = startNotes
		for j, k in enumerate(curNotes[::-1]):
			self.output[j].append(note.Note(k))
		totalNotes.append(curNotes)
		for i in intervalSequence:
			destSet = 0
			if isinstance(i, list):
				destSet = i[1]
				i = i[0]
			curNotes = self.move_chord(curNotes, i * multiplier, destSet)[0]
			totalNotes.append(curNotes)
			for j, k in enumerate(curNotes[::-1]):
				self.output[j].append(note.Note(k))
		if show:
			self.output.show('oldmusicxml')

	def apply(self, other, multiplier = 1, durationSequence = [1, 1, 1], show = True):						# applies the voice leadings in other.ChordSequence to self
		"""this will only work if the original sequence lies entirely within the first element of the second sequence, and if PC duplications are always given unique letternames"""
		seqLen = len(durationSequence)
		durationSequence = [x * multiplier for x in durationSequence]
		source = other.output
		sourceLen = len(other.output.parts[0]) - 1
		totalDurs = [durationSequence[0]]
		for i in range(len(self.output.parts[0])):
			if i >= sum(totalDurs):
				totalDurs.append(durationSequence[len(totalDurs) % seqLen])
			targetIndex = min(len(totalDurs) - 1, sourceLen)
			transposeDict = {}
			for myPart in other.output:
				sourceNote = myPart[0]
				targetNote = myPart[targetIndex]
				transposeDict[sourceNote.name] = interval.Interval(sourceNote, targetNote)
			for myPart in self.output:
				if myPart[i].name in transposeDict:
					myPart[i].transpose(transposeDict[myPart[i].name], inPlace = True)
				else:
					if myPart[i].name.count("#") > 0:
						myPart[i].transpose('d2', inPlace = True)
					elif myPart[i].name.count("-") > 0:
						myPart[i].transpose('-d2', inPlace = True)
					if myPart[i].name in transposeDict:
						myPart[i].transpose(transposeDict[myPart[i].name], inPlace = True)
					else:
						print("CAN'T FIND NOTE", myPart[i].name)
		if show:
			self.output.show('oldmusicxml')

	def arpeggiate(self, direction = 1, noteDuration = .25, show = True):		# direction can either be an int (1 = ascending, -1 = descending) or a sequence of parts
		if type(direction) is int:
			direction = range(len(self.output))[::direction]
		tempOutput = stream.Score()
		for i in range(len(self.output.parts[0])):
			for myPart in direction:
				tempOutput.append(note.Note(self.output[myPart][i].pitch, quarterLength = noteDuration))
		if show:
			tempOutput.show('oldmusicxml')

	def SDs_to_notenames(self, listOfSDs):
		listOfPCs = [self.theScale[x % self.modulus] for x in listOfSDs]			#chromatic PCs
		return ''.join(spell(listOfPCs))

	def graph(self, save = False, vlLabels = False, dim = 0, numSquares = 7, letternames = True, fontsize = 10):  # add fontsize

		baseSetLen = len(self.baseSet)

		if not dim:
			dim = min(self.dimension, 3)

		lastChord = [self.theCircle[-1][0][j] + self.theCircle[-1][1][j] for j in range(self.baseSetLen)]
		innerLabelsInts = [x[0] for x in self.theCircle]
		innerLabels = innerLabelsInts[:]
		transp = lastChord[0] - self.theCircle[0][0][0]

		for i in range(10):
			newList = innerLabelsInts[:]
			for j, theSet in enumerate(newList):
				newList[j] = [(theSet[x] + transp * (i + 1)) % self.modulus for x in range(self.baseSetLen)]
			innerLabels += newList

		outerLabels = [self.apply_VL(x, [self.baseSet, self.theCircle[1][1]]) for x in innerLabels]

		if dim > 2:
			outerLabels2 = [self.apply_VL(x, [self.baseSet, self.theCircle[2][1]]) for x in innerLabels]
			outerLabels3 = [self.apply_VL(x, [self.baseSet, add_vectors(self.theCircle[1][1], self.theCircle[2][1])]) for x in innerLabels]

			for i in range(len(outerLabels2)):
				outerLabels2[i] = [y % self.modulus for y in outerLabels2[i]]
			for i in range(len(outerLabels3)):
				outerLabels3[i] = [y % self.modulus for y in outerLabels3[i]]

		for i in range(len(outerLabels)):
			outerLabels[i] = [y % self.modulus for y in outerLabels[i]]

		vlStr = []

		if not vlLabels:
			for h, notes in enumerate(innerLabels):
				theVL = [[],[]]

				paths = self.theCircle[h % baseSetLen][1]
				for i, p in enumerate(paths):
					if p != 0:
						theVL[0].append(notes[i])
						theVL[1].append((notes[i] + p) % self.modulus)
				if letternames:
					vlStr.append(u''.join(self.SDs_to_notenames(theVL[0])) + u"\u2192" + u''.join(self.SDs_to_notenames(theVL[1])))
				else:
					vlStr.append(u''.join(PCs_to_strings(theVL[0])) + u"\u2192" + u''.join(PCs_to_strings(theVL[1])))
		else:
			for h in range(len((innerLabels))):
				paths = [str(s) for s in self.theCircle[h % baseSetLen][1]]
				vlStr.append(','.join(paths))

		if dim == 2:
			self.show_planar(innerLabels, outerLabels, vlStr, save = save, numSquares = numSquares, fontsize = fontsize, letternames = letternames)
		else:
			self.three_graph(innerLabels, outerLabels, outerLabels2, outerLabels3, fontsize = fontsize, letternames = letternames)

	def show_planar(self, circleLabels = ['CDEGA', 'BDEGA'], outerLabels = ['test1'], vlStr = ['dummy'], numSquares = 7, save = False, fontsize = 10, letternames = True):

		if type(circleLabels[0][0]) is int:
			if letternames:
				circleLabels = [self.SDs_to_notenames(x) for x in circleLabels]
				outerLabels = [self.SDs_to_notenames(x) for x in outerLabels]
			else:
				circleLabels = [PCs_to_strings(x) for x in circleLabels]
				outerLabels = [PCs_to_strings(x) for x in outerLabels]

		fig = plt.figure(figsize = (15, 6))
		ax = fig.gca()
		ax.set_axis_off()
		ax.set_facecolor('white')

		theStripe = []

		for i in range(int(numSquares)):
			theStripe.append([i, (i % 2)])
			x, y = separate_coordinates(make_square(theStripe[-1]))
			ax.plot(x, y, color = 'black')

		theStripe.append([i+1, (i+1) % 2])
		theStripe.append([i+2, (i+2) % 2])

		x, y = separate_coordinates(theStripe)

		ax.plot(x, y,color = 'black', linewidth = 5)

		lOffset = .15
		rOffset = .15

		for i in range(len(vlStr)):
			if i >=numSquares + 1:
				break
			if i % 2 == 0:
				ax.text(i + .5 - lOffset, .5 + lOffset, vlStr[i], ha = 'center', rotation = 45, fontsize = fontsize)
			else:
				ax.text(i + .5 + rOffset, .5 + rOffset, vlStr[i], ha = 'center', rotation = -45, fontsize = fontsize)

		offset = .2
		vOffset = 0.1

		for i, s in enumerate(circleLabels):
			if i >=numSquares + 2:
				break
			ax.text(i + offset, i % 2, s, fontsize = fontsize)

		for i, s in enumerate(outerLabels):
			if i >= numSquares:
				break
			if i % 2 == 0:
				ax.text(1 + i, -1 - vOffset, s, ha = 'center', fontsize = fontsize)
			else:
				ax.text(1 + i, 2 + vOffset, s, ha = 'center', fontsize = fontsize)

		ax.text(-.8, 2, ''.join([str(x) for x in self.baseSet])+' chord', fontsize = 24, ha = 'left')
		ax.text(-.8, 1.75, str(len(self.theScale))+'-note scale', fontsize = 24, ha = 'left')
		if letternames:
			ax.text(-.6, 1.5, ''.join(spell(self.theScale)), fontsize = 16, ha = 'left')

		if save:
			plt.savefig('/Users/dmitri/Desktop/' + save + '.jpg', dpi = 300)
		plt.show()

	def three_graph(self, circleLabels = ['CDEGA', 'BDEGA', 'BDEF#A', 'CDEGA', 'BDEGA', 'BDEF#A', 'CDEGA', 'BDEGA', 'BDEF#A', 'BDEF#A', 'BDEF#A', 'BDEF#A', 'BDEF#A'],
		outerLabels1 = ['test1', 'test2', 'test3', 'test4', 'test5', 'test6', 'test1', 'test2', 'test3', 'test4', 'test5', 'test6'],
		outerLabels2 = ['harm1', 'harm2', 'harm3', 'harm4', 'harm5', 'harm6', 'harm7', 'harm8', 'harm9', 'HARM4', 'HARM5', 'HARM6'],
		outerLabels3 = ['HARM1', 'HARM2', 'HARM3', 'HARM4', 'HARM5', 'HARM6', 'HARM1', 'HARM2', 'HARM3', 'HARM4', 'HARM5', 'HARM6'],
		vlStr = ['dummy'], numSquares = 4, save = False, fontsize = 10, letternames = True):

		theLabels = [circleLabels, outerLabels1, outerLabels2, outerLabels3]

		for i, labelList in enumerate(theLabels):
			if type(labelList[0][0]) is int:
				if letternames:
					theLabels[i] = [self.SDs_to_notenames(x) for x in labelList]
				else:
					theLabels[i] = [PCs_to_strings(x) for x in labelList]

		circleLabels, outerLabels1, outerLabels2, outerLabels3 = theLabels

		fig = plt.figure(figsize = (10, 10))
		fig.set_size_inches(10, 10)
		ax = fig.gca(projection='3d')
		ax.set_axis_off()

		mainSpine = [[0, 0, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [1, 1, 2], [2, 1, 2], [2, 2, 2]] # make extendible

		for myVertex in mainSpine[:numSquares]:
			theLines = make_cube(myVertex, add_vectors(myVertex, [1, 1, 1]))
			x, y, z = separate_coordinates(theLines)
			ax.plot(x, y, z, color = 'black')

		x, y, z = separate_coordinates(mainSpine)
		ax.plot(x, y, z, color = 'black', linewidth = 5)

		centerLabelOffsets = [-.1, 0, -.1]
		extraYOffset = [-.15, .6, 0]

		acousticLabels = [[1, 0, 0], [0, 1, 1], [1, 0, 2], [2, 1, 1], [1, 2, 2]]	# make extendible

		for i, s in enumerate(mainSpine):
			if i >= numSquares + 3:
				break
			myVec = add_vectors(s, centerLabelOffsets)
			if i > 2:
				myVec = add_vectors(myVec, extraYOffset)
			x, y, z = myVec
			ax.text(x, y, z, circleLabels[i], ha = 'right', fontsize = fontsize)

		outerLabelOffsets = (-.02, -.1, -.14)
		extraYOffset = (-.03, 0, .11)
		additionalOffsets = [[.05, 0., .05], [-.03, .1, 0], [.04, 0, -.04], [.1, 0, 0], [-.1, .3, 0], 0, 0, 0, 0, 0]

		for i, s in enumerate(acousticLabels):
			if i >= numSquares + 1:
				break
			myVec = add_vectors(s, outerLabelOffsets)
			if myVec[2] > .3:
				myVec = add_vectors(myVec, extraYOffset)
			if additionalOffsets[i]:
				myVec = add_vectors(myVec, additionalOffsets[i])
			x, y, z = myVec
			if i != 3:
				ax.text(x, y, z, outerLabels1[i], ha = 'right', fontsize = fontsize)
			else:
				ax.text(x, y, z, outerLabels1[i], ha = 'left', fontsize = fontsize)

		harmLabels = [[0, 1, 0], [0, 0, 2], [2, 0, 1], [1, 2, 1]]	# make extendible

		outerLabelOffsets = [-.05, .05, -.05]
		additionalOffsets = [[-.02, .05, 0], 0, [.05, -.13, 0], [-.02, .1, .03], 0, 0, 0, 0, 0, 0]

		for i, s in enumerate(harmLabels):
			if i >= numSquares:
				break
			myVec = add_vectors(s, outerLabelOffsets)
			if additionalOffsets[i]:
				myVec = add_vectors(myVec, additionalOffsets[i])
			x, y, z = myVec
			ax.text(x, y, z, outerLabels2[i], ha = 'right', fontsize = fontsize)

		HARMLabels = [[1, 1, 0], [0, 1, 2], [2, 0, 2], [2, 2, 1]]	# make extendible

		outerLabelOffsets = [-.05, .05, .05]
		additionalOffsets = [0, 0, [.05, -.04, -.01], [.1, 0, -.1], 0, 0, 0, 0, 0]

		for i, s in enumerate(HARMLabels):
			if i >= numSquares:
				break
			myVec = add_vectors(s, outerLabelOffsets)
			if additionalOffsets[i]:
				myVec = add_vectors(myVec, additionalOffsets[i])
			x, y, z = myVec
			if i != 3:
				ax.text(x, y, z, outerLabels3[i], ha = 'right', fontsize = fontsize)		# two things should be left justified
			else:
				ax.text(x, y, z, outerLabels3[i], ha = 'left', fontsize = fontsize)

		ax.view_init(elev=17, azim=-70)

		ax.text(1.8, 0, 0, ''.join([str(x) for x in self.baseSet])+' chord', fontsize = 24, ha = 'left')
		ax.text(1.8, 0, -.2, str(len(self.theScale))+'-note scale', fontsize = 24, ha = 'left')
		if letternames:
			ax.text(1.9, 0, -.35, ''.join(spell(self.theScale)), fontsize = 16, ha = 'left')

		if save:
			plt.savefig('/Users/dmitri/Desktop/' + save + '.jpg', dpi = 300)

		plt.show()
